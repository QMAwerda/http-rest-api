
Первым делом мы инициализируем модуль go. Это инструмент для работы с зависимостями(внешними библиотеками)
Далее мы создаем файл main.go, который будет точкой входа приложения. Мы размещаем его в cmd/apiserver/
Чтобы удобно огранизовать команды сборки и другие команды и не бояться, что ты что-то упустишь + ускорить их использование
мы создаем Makefile, который содержит инструкции по выполнению и работает через make (СМОТРИ ПОДРОБНЕЕ)
.DEFAULT_GOAL := build устанавливает процедуру build по умолчанию, мы можем вызвать ее через make.
В Makefile в будущем мы добавим команды для запуска тестов, "линтелки" и тд. И чтобы эти команды не складывать в README или 
не запоминать, мы фиксируем их в Makefile.

Далее мы создаем пакет с самими api сервером. internal/app/apiserver хранит эти файлы. Мы не реализуем тут бизнес-логику, тут
реализована внутренняя работа нашего сервера, которая в последсвии будет использоваться во всех ручках(если я правильно понимаю).
В этом пакете мы создаем структуру API сервера, метод New(), в котором инициализируем эту структуру (будто сеттер) и метод Start(),
который принимает экземпляр нашей структуры API сервера и нужен для запуска http сервера и подключения к базе данных.

Теперь мы создаем объект сервера в main.go, если err(результат отработки фукнции) не равен nil, то мы выходим с log.Fatal()
log - (я так понимаю) страндартная библиотека для работы с потоком ошибок. Нужно узнать, как это тут реализовано.

Мы должны научить наш сервер конфигурироваться (выбирать введенный нами порт для запуска вебсервера или url конфига доступа к базе
данных). Мы рассмотрим конфигурацию на примере toml файла. Т.е. это конфигурационный файл в формате toml.
Для этого создаем в internal/api/apiserver файл config.go, в котором создадим структуру Config, которая будет хранить наши настройки.
Добавим в нее строку BindAddr, которая будет хранить адрес, на котором мы запускаем наш вебсервер. Сразу прописываем ему тег, для
библиотеки toml, т.е. `toml:"bind_addr"` Таким образом мы сможем удобно переводить поля экземпляра нашей структуры в toml файл.
Там же создаем функцию NewConfig(), которая будет возвращать проинициализированный экземпляр структуры конфига
с дефолтными параметрами.

Теперь добавляем в нашу структуру API сервера поле config, где мы будем хранить экземпляр структуры Config. Ну и соответсвенно
в методе New(), инициализирующем наш API сервер, получаем парамтером config *Config из вне и инициализируем наше поле config.

Далее в отдельной папке configs создаем конфигурационный файл toml, куда добавляем наш параметр bind_addr = ":8080" 
Для парсинга toml мы используем зависимость BurntSushi/toml, которую добавляем так: go get github.com/... это добавит в go.mod
зависимость.

Теперь в фукнции main.go добавим создание конфига и передадим этот параметр в создание экземпляра сервера

Теперь нам нужно, чтобы мы могли при запуске бинарника передавать параемтром в качестве флага путь до конфига.
Для этого создаем string переменную var (вроде это глобал) с именем configPath. Далее функцию, где мы парсим флаг в переменную
configPath при флаге "config-path", по умолчанию у него будет значение "configs/apiserver.toml", описание -help будет 
"path to config file"
Общая команда: flag.StringVar(&configPath, "config-path", "configs/apiserver.toml, "path to config file"). Узнать про эту команду.
А в main мы вызываем flag.Parse(), который парсит флаги, при вызове из консоли. Используем библу toml, чтобы прочитать файл и
распарсить его.
_, err := toml.DecodeFile(configPath, config). Параметры: путь до нашего файла с конфигом, переменная, в которую мы хотим записать
(Проверь, что возвращает этот метод и смысл этой штуки "_" )

Тестируем парсинг флагов. Собираем проект с помощью make (который запускает go build ... короче main.go)
Вызываем сервер ./apiserver -help (т.е. make билдит нам прогу и запускает ее, а на ее первой строке мы парсим флаги). Т.е. мы 
вводим команду в работающую у нас программу. А если ввести флаг -help, то мы увидим путь по умолчанию. (НЕ ПОНИМАЮ, почему при вводе
нужно указать ./apiserver) Первое - как он понимает, что ./apiserver лежит внутри cmd (допустим, он уже там запустился и оттуда ищет)
Второе - даже если так, зачем указывать ./apiserver? Думаю, ответ должен быть в команде flag.parse()

Теперь добавим логирование с библиотекой logrus. Логирование - ценный инструмент для тестирования, который демонстрирует нам, что
сервис работает коррректно или некорректно. Логи - записи событий или сообщений, создаваемые программой во время ее работы. Они
представляют информацию о том, что происходит внутри приложения в определенный момент времени. Они содержат разные данные, такие как
сообщения об ошибках, предупреждения, инфа о выполнении определенных действий и тд. Короче, без них никак.
В логи смотрят при тестировании новых фич, при релизе, для более точного определения бага, оценки правильности приложения и тд.

Теперь переходим в наш config.go и добавляем в структуру поле для режима работы логруса (там могут быть разные уровни логирования),
их удобно менять, например, повышая уровень значимости, чтобы не засорять логи лишней инфой. Или наоборот, чтобы получить больше инфы
при отладке. Есть несколько уровней логирования (FATAL, ERROR, WARN, INFO, DEBUG, TRACE). Через установленный уровень в лог попадут
только сообщения выбранного уровня и те, что выше. Т.е. если установить лог левел на error, то мы не увидим WARN, INFO и тд. уровень
сообщения, которое попадет в лог мы ставим сами, используя библу логрус (в зависимости от контекста ставим ей важность).
Итак, поле называем LogLevel string `toml:"log_level"` (сразу пишем тег для томл файла, погугли про это)
В создании конфига (инициализация этой стрктуры), ставим дефолтное значения режима работы логера на "debug".

Теперь добавляем логер в качестве поля нашего API сервера (стрктуры) это будет logrus.Logger

В функции New(config *Config) *APIServer, создающей наш APIServer добавим инициализацию поля logger новым логгером, т.е.
logger: logrus.New(). (Опять же, интересно, используется ли тут как в c++ pole = _pole при передаче параметров, или можно оставить
имя параметра такое же как название поля и golang сам определит что куда подставить?)

Теперь мы добавим функцию, которая конфигурирует наш логгер. (в тот же файл apiserver.go), назовем ее configureLogger(). Она может
вернуть ошибку, если мы укажем неправильный уровень логирования, передав некорректную строку. В нем парсим строку с конфигом, где 
есть поле с уровнем логгера.
level, err := logrus.ParseLevel(s.config.LogLevel)
если есть ошибка, мы ее возвращаем (отлов ее произойдет в main.go), а если ошибок нет, то устанавливаем уровень логгеру:
s.logger.SetLevel(level)

Теперь настраиваем метод Start() (в apiserver.go). Запускаем логгер и проверяем его работу:
if err := s.configureLogger(); err != nil {return err}
Если все ок, пишем сообщение в логгер с уровнем INFO:
s.logger.Info("starting api server").

Для проверки введем ./apiserver в консоль и увидим: INFO[0000] starting api server. Где 0000 - номер события

Добавляем в toml файл параметр log_level="debug" (Пока мы не писали этот параметр, у нас был уровень по дефолту?) Я так понимаю, по 
дефолту там info.

Если поменять log_level до уровня error, то он не пропустит событий, ниже error, поэтому при вызове сервера логгер ничего не запишет

Теперь приложение умееет конфигурироваться и логироваться, пора заняться http сервером. Сперва создаем роутер, который будет 
обрабатывать все входящие запросы и перенаправлять их к нужным обработчикам. В качестве роутера воспользуемся гориллой mux.
Добавим поле router в APIServer, проинициализируем его в методе New(); router: mux.NewRouter()

Добавим метод для конфигурации роутера (он просто описывает ее, не может вернуть ошибку):
func (s *APIServer) configureRouter() {
    s.router.HandleFunc("/hello", s.handleHello()) - т.е. запрос "/hello" будет обрабатываться функцией handleHello (обработчик)
}
func (s *APIServer) handleHello() http.HanderFunc {
    return func(w http.ResponseWriter, r * http.Request) {

    } - мы возвращаем функцию, потому что в таком случае выше нее можно определить какие-то переменные, которые будут использоваться
    только в этом хендлере. Этот код выполнится всего один раз, также можно определить локальные специальные типы. Например тип 
    request, который приходит в наш обработчик.

    io.WriteString(w, "Hello") // что за io и метод? Что такое ResponseWriter? Для чего возвращаем из метода именно такую функцию?
}

Добавим в метод Start() метод s.configureRouter()
И будем возвращать из него http.ListenAndServe(s.config.BindAddr, s.router) - адрес(порта), роутер(обработчик)

Покроем этот тестовый метод тестами. Добавим библиотеку stretcher/testify
Создаем файл с тестом. apiserver_internal_test.go - internal, потому что мы тестируем внутренние, непубличные методы. Публичные 
принято тестировать в файлах с названием _test. А внутрениие с названием internal_test.

s:= New(NewConfig())
rec := httptest.NewRecorder() - рекордер
rec, _ := http.NewRequest(http.MethodGet, "/hello", nil) - реквест. Метод, путь, nil
s.handleHello().ServeHTTP(rec, req)
assert.Equal(t, rec.Body.String(), "Hello") - проверяем что тело рекордера равно hello

И добавим задачу в Makefile:
.PHONY: test
test:   
    go test -v -race -timeout 30s ./... (таймаут 30 сек на все пакеты внутри репозитория)
    